#!/bin/bash
# Author: jules randolph <jules.sam.randolph@gmail.com> https://github.com/jsamr
# License: MIT
# Version 2.6.0
#
# Create a bootable USB from any ISO securely.
# Usage: bootiso [<options>...] <file.iso>
#        bootiso --dd [<options>...] <file.iso>
#        bootiso <action> [<options>...]
#
# The default action as per first synopsis is to install an ISO file to a USB device with rsync.
# Option and action flags can be stacked in their POSIX form.
#
# ACTION FLAGS
#
# You can change the action with bellow flags:
#
# -h, --help, help             Display this help message and exit.
# -v, --version                Display version and exit.
# -l, --list-usb-drives        List available USB drives and exit.
# -f, --format                 Format selected USB drive and exit.
#     --dd                     Install ISO with `dd' utility instead of mounting + `rsync'.
#                              Does not allow bootloader installation with syslinux.
# OPTION FLAGS
#
# -d, --device  <device>       Select <device> block file as USB device.
#                              If <device> is not connected through USB, `bootiso' will fail and exit.
#                              Device block files are usually situated in /dev/sdX or /dev/hdX.
#                              You will be prompted to select a device if you don't use this option.
# -t, --type <type>            Format to `<type>' instead of standard FAT32 (vfat). Supported types: vfat exfat ntfs ext3 ext4 f2fs.
#                              Only works with `install-rsync' and `format' actions.
# -L, --label <label>          Use `<label>' instead of ISO name. Also work with `-f' option.
#                              `bootiso' will strip labels which are too long regarding the selected filesystem (-t), and uppercase
#                              FAT32 (vfat) labels.
# -b, --bootloader             Install a bootloader with syslinux (safe mode) for non-hybrid ISOs.
#                              Does not work with `--dd' option.
#                              Does not works when selecting a partition type different from FAT32 (vfat).
# -y, --assume-yes             `bootiso' won't prompt the user for confirmation before erasing and partitioning USB device.
#                              [1;33mUse at your own risks.[0m
# -a, --autoselect             Enable autoselecting USB devices in conjunction with -y option.
#                              Autoselect will automatically select a USB drive device if there is exactly one connected to the system.
#                              Enabled by default when neither -d nor --no-usb-check options are given.
# -J, --no-eject               Do not eject device after unmounting.
# -M, --no-mime-check          `bootiso' won't assert that selected ISO file has the right mime-type.
# -s, --strict-mime-check      Disallow loose application/octet-stream mime type in ISO file.
#     --                       POSIX end of options.
#     --no-usb-check           `bootiso' won't assert that selected device is a USB (connected through USB bus).
#                              [0;31mUse at your own risks.[0m
#
#
# How it works (install-rsync action)
#
# The script walks through the following steps:
# 1. Request sudo.
# 2. Check commandDependencies and prompt user to install any missing.
# 3. If not given the -M, --no-mime-check option, assert that provided ISO exists and has the expected application/x-iso9660-image mime-type via `file' utiltiy. If the assertion fails, exit with error status.
# 4. If given the -d, --device option, check that the selected device exists and is not a partition. Otherwise, prompt the user to select a device and perform the above-mentioned controls.
# 5. If not given the --no-usb-check option, assert that the given device is connected through USB via `udevadm' utility. If the assertion fails, exit with error status.
# 6. If not given the -y, --assume-yes option, prompt the user for confirmation that data might be lost for selected device if he goes to next step.
# 7. Unmount the USB if mounted, blank it and delete existing partitions.
# 8. Create a partition on the USB device.
# 9. Create a temporary dir to mount the ISO file and mount it.
# 10. Create a temporary dir to mount the USB device and mount it.
# 11. Copy files from ISO to USB device.
# 12. If option -b, --bootloader is selected, install a bootloader with syslinux in slow mode.
# 13. Unmount devices and remove temporary folders.
# 14. Eject USB device if -J, --no-eject is not selected

set -o pipefail
set -E

scriptName=$(basename "$0")
bashVersion=$(echo "$BASH_VERSION" | cut -d. -f1)

if [ -z "$BASH_VERSION" ] || [ "$bashVersion" -lt 4 ]; then
  echoerr "You need bash v4+ to run this script. Aborting..."
  exit 1
fi

# program constrains definitions
typeset -ar commandDependencies=('lsblk' 'sfdisk' 'mkfs' 'blkid' 'wipefs' 'grep' 'file' 'awk' 'mlabel')
typeset -Ar commandPackages=(
  [lsblk]='util-linux'
  [sfdisk]='util-linux'
  [mkfs]='util-linux'
  [blkid]='util-linux'
  [wipefs]='util-linux'
  [grep]='grep'
  [file]='file'
  [awk]='gawk'
  [mlabel]='mtools'
  [syslinux]='syslinux'
  [rsync]='rsync'
)
typeset shortOptions='bydJahlsMftL'
typeset -ar supportedFS=('vfat' 'exfat' 'ntfs' 'ext2' 'ext3' 'ext4' 'f2fs')
typeset -Ar userVarsCompatibilityMatrix=(
  [iso-file]='install-rsync install-dd'
  [device]='install-rsync install-dd format'
  [type]='install-rsync format'
  [label]='install-rsync format'
)
typeset -Ar userFlagsCompatibilityMatrix=(
  [bootloader]='install-rsync format'
  [assume-yes]='install-rsync install-dd format'
  [no-eject]='install-rsync install-dd format'
  [autoselect]='install-rsync install-dd format'
  [no-mime-check]='install-rsync install-dd'
  [strict-mime-check]='install-rsync install-dd'
  [no-usb-check]='install-rsync install-dd format'
)

# internal variables
typeset version="2.6.0"
typeset selectedPartition
typeset isoMountPoint
typeset usbMountPoint
typeset startTime
typeset endTime
typeset -a devicesList
typeset operationSuccess
typeset expectingISOFile

typeset -A userFlags=(
  # Actions
  [help]=''
  [version]=''
  [list-usb-drives]=''
  [format]=''
  [dd]=''
  # Options
  [bootloader]=''
  [assume-yes]=''
  [device]=''
  [no-eject]=''
  [autoselect]=''
  [no-mime-check]=''
  [strict-mime-check]=''
  [no-usb-check]=''
)

typeset -A userVars=(
  [iso-file]=''
  [device]=''
  [type]=''
  [label]=''
)

# user defined variables
typeset selectedIsoFile
typeset selectedDevice
typeset partitionLabel
typeset partitionType # default to vfat
typeset action='install-rsync'

# options
typeset addSyslinuxBootloader
typeset disableMimeCheck
typeset disableUSBCheck
typeset disableConfirmation
typeset autoselect
typeset strictMimeCheck
typeset shouldMakePartition
typeset noDeviceEjection

# $1: The text to colorify.
redify() {
  echo -e "\\033[0;31m$1\\033[0m"
}

# $1: The text to colorify.
greenify() {
  echo -e "\\033[0;32m$1\\033[0m"
}

# $1: The text to colorify.
yellowify() {
 echo -e "\\033[1;33m$1\\033[0m"
}

typeset help_message="\
Create a bootable USB from any ISO securely.
Usage: $scriptName [<options>...] <file.iso>
       $scriptName --dd [<options>...] <file.iso>
       $scriptName <action> [<options>...]

The default action [install-rsync] as per first synopsis is to install an ISO file to a USB device with rsync.
Option and action flags can be stacked in their POSIX form.

ACTION FLAGS

You can change the default [install-rsync] action with bellow flags (cannonical names given in brackets):

-h, --help, help             [help]
                             Display this help message and exit.
-v, --version                [version]
                             Display version and exit.
-l, --list-usb-drives        [list-usb-drives]
                             List available USB drives and exit.
-f, --format                 [format]
                             Format selected USB drive and exit.
     --dd                    [install-dd]
                             Install ISO with \`dd' utility instead of mounting + \`rsync'.
                             Does not allow bootloader installation with syslinux.
OPTION FLAGS

-d, --device  <device>       Select <device> block file as USB device.
                             If <device> is not connected through USB, $scriptName will fail and exit.
                             Device block files are usually situated in /dev/sdX or /dev/hdX.
                             You will be prompted to select a device if you don't use this option.
-t, --type <type>            Format to \`<type>' instead of standard FAT32 (vfat). Supported types: ${supportedFS[*]}.
                             Only works with [install-rsync] and [format] actions.
-L, --label <label>          Use \`<label>' instead of ISO name. Also work with \`-f' option.
                             $scriptName will strip labels which are too long regarding the selected filesystem (-t), and uppercase
                             FAT32 (vfat) labels.
-b, --bootloader             Install a bootloader with syslinux (safe mode) for non-hybrid ISOs.
                             Does not work with \`--dd' flag [install-dd].
                             Does not works when selecting a partition type different from FAT32 (vfat).
-y, --assume-yes             $scriptName won't prompt the user for confirmation before erasing and partitioning USB device.
                             $(yellowify 'Use at your own risks.')
-a, --autoselect             Enable autoselecting USB devices in conjunction with -y option.
                             Autoselect will automatically select a USB drive device if there is exactly one connected to the system.
                             Enabled by default when neither \`-d' nor \`--no-usb-check' options are given.
-J, --no-eject               Do not eject device after unmounting.
-M, --no-mime-check          $scriptName won't assert that selected ISO file has the right mime-type.
-s, --strict-mime-check      Disallow loose application/octet-stream mime type in ISO file.
    --                       POSIX end of options.
    --no-usb-check           $scriptName won't assert that selected device is a USB (connected through USB bus).
                             $(redify 'Use at your own risks.')

INFO

    Bootiso v$version.
    Author: Jules Samuel Randolph
    Bugs and new features: https://github.com/jsamr/bootiso/issues

    If you like bootiso, feel free to help the community by making it visible:
    * star the project at https://github.com/jsamr/bootiso
    * upvote those SE post: https://goo.gl/BNRmvm https://goo.gl/YDBvFe
"

display_help() {
  echo -e "$help_message"
}

indent() {
  sed -e ':a;N;$!ba;s/\n/\n         /g'
}

indentAll() {
  sed -e 's/^/         /'
}

# $1: The message to print.
echoerr() {
  redify "$scriptName: $1" | indent >&2
}

# $1: The message to print.
echowarn() {
  yellowify "$scriptName: $1" | indent
}

# $1: The message to print.
echogood() {
  greenify "$scriptName: $1" | indent
}

# $1: The message to print.
echoinfo() {
  echo -e "$scriptName: $1" | indent
}

# $1: The message to print.
failAndExit() {
  echoerr "$1\\nExiting..."
  exit 1
}

# $1: The name of the command to check against $PATH.
hasPackage() {
  command -v "$1" &> /dev/null
  return $?
}

initPckgManager() {
  if hasPackage apt-get; then # Debian
    pkgmgr="apt-get -y install"
    return 0
  fi
  if hasPackage dnf; then # Fedora
    pkgmgr="dnf -y install"
    return 0
  fi
  if hasPackage yum; then # Fedora
    pkgmgr="yum -y install"
    return 0
  fi
  if hasPackage pacman; then # Arch
    pkgmgr="pacman -S --noconfirm"
    return 0
  fi
  if hasPackage zypper; then # OpenSuse
    pkgmgr="zypper install"
    return 0
  fi
  if hasPackage emerge; then # Gentoo
    pkgmgr="emerge"
    return 0
  fi
  return 1
}

checkSudo() {
  if ((EUID != 0)); then
    echoinfo "Granting root privileges."
    if [[ -t 1 ]]; then
      sudo "$0" "$@"
    else
      exec 1>output_file
      gksu "$0" "$@"
    fi
    exit
  fi
}

failISOCheck() {
  echoerr "Provided file \`$selectedIsoFile' doesn't seem to be an ISO file (wrong mime type: \`$mimetype')."
  echowarn "You can bypass this policy with \`-M, --no-mime-check' option, but it is likely that operation will fail."
  echoerr "Exiting..."
  exit 1
}

assertISOIsOK() {
  typeset mimetype
  typeset -i isOctetStream
  if [ -z "$selectedIsoFile" ]; then
    echoerr "Missing argument \`iso-file'."
    exit 2
  fi
  if [ -d "$selectedIsoFile" ]; then
    failAndExit "Provided file \`$selectedIsoFile' is a directory."
  fi
  if [ ! -f "$selectedIsoFile" ]; then
    failAndExit "Provided iso file \`$selectedIsoFile' does not exists."
  fi
  mimetype=$(file --mime-type  -b -- "$selectedIsoFile")
  if [ "$disableMimeCheck" == 'true' ]; then
    echowarn "Mime check has been disabled with \`--no-mime-check'. Skipping."
    return 0
  fi
  [ "$mimetype" == "application/octet-stream"  ]
  isOctetStream=$?
  if [ "$strictMimeCheck" == 'true' ] && ((isOctetStream == 0)); then
    failISOCheck
  fi
  if ((isOctetStream != 0)) &&  [ ! "$mimetype" == "application/x-iso9660-image" ]; then
    failISOCheck
  fi
  # warnings
  if ((EUID == 0)); then
    if ((isOctetStream == 0)); then
      echowarn "Provided file \`$selectedIsoFile' seems to have a loose mime-type \`application/octet-stream'.\\nIt's possible that it is corrupted and you should control its integrity with a checksum tool."
    else
      echogood "The selected ISO file has the right \`application/x-iso9660-image' mime type."
    fi
  fi
}

configureLabel() {
  partitionLabel=${partitionLabel:-$(blkid -o value -s LABEL -- "$selectedIsoFile")}
  case $partitionType in
    vfat)
    # Label to uppercase, otherwise some DOS systems won't work properly
    partitionLabel=${partitionLabel^^}
    # FAT32 labels have maximum 11 chars
    partitionLabel=${partitionLabel:0:11}
    ;;
    exfat)
    # EXFAT labels have maximum 15 chars
    partitionLabel=${partitionLabel:0:15}
    ;;
    ntfs)
    # NTFS labels have maximum 32 chars
    partitionLabel=${partitionLabel:0:32}
    ;;
    ext2|ext3|ext4)
    # EXT labels have maximum 16 chars
    partitionLabel=${partitionLabel:0:16}
    ;;
  esac
  # Default to "BOOTISO"
  partitionLabel=${partitionLabel:-"BOOTISO"}
  if [ -z "${userVars[label]}" ]; then
    echogood "Partition label automatically set to \`$partitionLabel'.\\nYou can explicitly set label with \`-L, --label' option."
  else
    echogood "Partition label manually set to \`$partitionLabel'."
  fi

}

# $1: The name of the package command to check.
checkpkg() {
  if ! hasPackage "$1"; then
    echowarn "Package '$1' not found!"
    if [ ! -z "$pkgmgr" ]; then
      read -r -n1 -p "Attempt installation? (y/n)>" answer
      echo
      case $answer in
        y) $pkgmgr "${commandPackages["$1"]}"
        ;;
        n)
        read -r -n1 -p "Proceed anyway? (y/n)>" answer2
        echo
        if [[ "$answer2" == "n" ]] ; then exit 1
      fi
      ;;
    esac
  else
    failAndExit "Missing dependency \`$1'."
  fi
fi
}

# $1: The string by which elements will be joined.
# $2-* : the elements to join
joinBy() {
  local IFS=$1;
  shift;
  echo "$*";
}

# $1: The element to check.
# $2-* : the list to check against.
containsElement () {
  local e match="$1"
  shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

initDevicesList() {
  typeset -a devices
  mapfile -t devices < <(lsblk -o NAME,TYPE | grep --color=never -oP '^\K\w+(?=\s+disk$)')
  for device in "${devices[@]}" ; do
    if [ "$(getDeviceType "/dev/$device")" == "usb" ] || [ "$disableUSBCheck" == 'true' ]; then
      devicesList+=("$device")
    fi
  done
}

listDevicesTable() {
  typeset lsblkCmd='lsblk -o NAME,HOTPLUG,SIZE,STATE,TYPE'
  initDevicesList
  if [ "$disableUSBCheck" == 'false' ]; then
    echoinfo "Listing USB drives available in your system:"
  else
    echoinfo "Listing devices available in your system:"
  fi
  if [ "${#devicesList[@]}" -gt 0 ]; then
    $lsblkCmd | sed -n 1p | sed 's/^/         /'
    $lsblkCmd | grep --color=never -P "^($(joinBy '|' "${devicesList[@]}"))" | sed 's/^/         /'
    return 0
  else
    echowarn "Couldn't find any USB drive in your system.\\nIf any is physically plugged in, it's likely that it has been ejected and should be plugged-in again to be discoverable.\\nYou can check the availability of USB drives with \`$scriptName -l' command."
    return 1
  fi
}

parseArguments() {
  enableUserFlag() {
    userFlags[$1]=true
  }
  setUserVar() {
    userVars[$1]=$2
  }
  typeset key
  typeset isEndOfOptions=false
  while [[ $# -gt 0 ]]; do
    key="$1"
    if [ "$isEndOfOptions" == 'false' ]; then
      case $key in
        # ACTIONS
        -h|--help|help)
          enableUserFlag 'help'
          shift
        ;;
        -v|--version)
          enableUserFlag 'version'
          shift
        ;;
        -l|--list-usb-drives)
          enableUserFlag 'list-usb-drives'
          shift
        ;;
        -f|--format)
          enableUserFlag 'format'
          shift
        ;;
        --dd)
          enableUserFlag 'install-dd'
          shift
        ;;
        # OPTIONS
        -b|--bootloader)
          enableUserFlag 'bootloader'
          shift
        ;;
        -y|--assume-yes)
          enableUserFlag 'assume-yes'
          shift
        ;;
        -d|--device)
          if (($# < 2)); then
            failAndExit "Missing value for \`$1' flag. Please provide a device."
          fi
          setUserVar 'device' "$2"
          shift 2
        ;;
        -t|--type)
          if (($# < 2)); then
            failAndExit "Missing value for \`$1' flag. Please provide a filesystem type."
          fi
          setUserVar 'type' "${2,,}" #lowercased
          shift 2
        ;;
        -L|--label)
          if (($# < 2)); then
            failAndExit "Missing value for \`$1' flag. Please provide a label."
          fi
          setUserVar 'label' "$2"
          shift 2
        ;;
        -J|--no-eject)
          enableUserFlag 'no-eject'
          shift
        ;;
        -a|--autoselect)
          enableUserFlag 'autoselect'
          shift
        ;;
        -M|--no-mime-check)
          enableUserFlag 'no-mime-check'
          shift
        ;;
        -s|--strict-mime-check)
          enableUserFlag 'strict-mime-check'
          shift
        ;;
        --no-usb-check)
          enableUserFlag 'no-usb-check'
          shift
        ;;
        --)
          isEndOfOptions=true
          shift
        ;;
        -*)
        # Probably an option, possibly a file.
        if [ ! -f "$key" ]; then
          # Assume it's stacked options
          if [[ "$key" =~ ^-["$shortOptions"]{2,}$ ]]; then
            shift
            typeset options=${key#*-}
            typeset -a extractedOptions
            mapfile -t extractedOptions < <(echo "$options" | grep -o . | xargs -d '\n' -n1 printf '-%s\n')
            set -- "${extractedOptions[@]}" "$@"
          else
            printf "\\e[0;31m%s\\e[m" "$scriptName: Unknown option: "
            printf '%s' "$key" | GREP_COLORS='mt=00;32:sl=00;31' grep --color=always -P "[$shortOptions]"
            if [[ "$key" =~ ^-[a-zA-Z0-9]+$ ]]; then
              typeset wrongOptions=$(printf '%s' "${key#*-}" | grep -Po "[^$shortOptions]" | tr -d '\n')
              if [ ${#key} -eq 2 ]; then
                yellowify "flag: \\033[0;31m\`$wrongOptions'\\033[0m."
              else
                yellowify "stacked flags: \\033[0;31m\`$wrongOptions'\\033[0m."
              fi

            fi
            echoerr "Exiting..."
            exit 2
          fi
        else
          # Happened to be a file.
          setUserVar 'iso-file' "$1"
          shift
        fi
        ;;
        *)
        setUserVar 'iso-file' "$1"
        shift
        ;;
      esac
  else
    setUserVar 'iso-file' "$1"
    break
  fi
  done
}

checkPackages() {
  for pkg in "${commandDependencies[@]}"; do
    checkpkg "$pkg"
  done
  # test grep supports -P option
  if ! echo 1 | grep -P '1' &> /dev/null; then
    failAndExit "You're using an old version of grep which does not support perl regular expression (-P option)."
  fi

}

# $1 : the folder name prefix
# print the name of the new folder if operation succeeded, fails otherwise
createTempFolder() {
  typeset tmpFileTemplate="/tmp/$1.XXX"
  mktemp -d "$tmpFileTemplate"
  typeset status=$?
  if [ ! $status -eq 0 ]; then
    failAndExit "Failed to create temporary folder"
  fi
}

mountIsoFile() {
  isoMountPoint=$(createTempFolder iso) || exit 1
  echogood "Created ISO mount point at \`$isoMountPoint'"
  if ! mount -r -o loop -- "$selectedIsoFile" "$isoMountPoint" > /dev/null; then
    failAndExit "Could not mount ISO file."
  fi
}

# $1 :  a device block
# Return 0 if device is USB, 1 otherwise
getDeviceType() {
  typeset deviceName=/sys/block/${1#/dev/}
  typeset deviceType=$(udevadm info --query=property --path="$deviceName" | grep -Po 'ID_BUS=\K\w+')
  echo "$deviceType"
}

deviceIsDisk() {
  lsblk --nodeps -o NAME,TYPE "$1" | grep -q disk
  return $?
}

selectDevice() {
  typeset _selectedDevice
  chooseDevice() {
    echoinfo "Select the device corresponding to the USB device you want to make bootable among: $(joinBy ',' "${devicesList[@]}")\\nType CTRL+D to quit."
    read -r -p "Select device id>" _selectedDevice
    echo
    if containsElement "$_selectedDevice" "${devicesList[@]}"; then
      selectedDevice="/dev/$_selectedDevice"
    else
      if containsElement "$_selectedDevice" "" "exit"; then
        echoinfo "Exiting on user request."
        exit 0
      else
        failAndExit "The drive $_selectedDevice does not exist."
      fi
    fi
  }
  handleDeviceSelection() {
    if [ ${#devicesList[@]} -eq 1 ] && [ "$disableUSBCheck" == 'false' ]; then
      # autoselect
      if [ "$disableConfirmation" == 'false' ] || ([ "$disableConfirmation" == 'true' ] && [ "$autoselect" == 'true' ]); then
        typeset selected="${devicesList[0]}"
        echogood "Autoselecting \`$selected' (only USB device candidate)"
        selectedDevice="/dev/$selected"
      else
        chooseDevice
      fi
    else
      chooseDevice
    fi
  }
  if [ -z "$selectedDevice" ]; then
    # List all hard disk drives
    if listDevicesTable; then
      handleDeviceSelection
    else
      echoerr "There is no USB drive connected to your system."
      echowarn "Use \`--no-usb-check' to bypass this policy at your own risk, or replug your USB device which is likely ejected.\\nYou can check the availability of USB drives with \`$scriptName -l' command."
      echoerr "Exiting..."
      exit 1
    fi
  fi
  selectedPartition="${selectedDevice}1"
}

assertDeviceIsOK() {
  typeset device=$1
  if [ ! -e "$device" ]; then
    failAndExit "The selected device \`$device' does not exists"
  fi
  if [ ! -b "$device" ]; then
    failAndExit "The selected device \`$device' is not a valid block file."
  fi
  if ! deviceIsDisk "$device"; then
    failAndExit "The selected device \`$device' is either unmounted or not a disk (might be a partition or loop).\\nSelect a disk instead or replug the USB device.\\nYou can check the availability of USB drives with \`$scriptName -l' command."
  fi
}

assertDeviceIsUSB() {
  typeset deviceType
  if [ "$disableUSBCheck" == 'true' ]; then
    echowarn "USB check has been disabled. Skipping."
    return 0
  fi
  deviceType=$(getDeviceType "$selectedDevice")
  if [ "$deviceType" != "usb" ]  ; then
    echoerr "The device you selected is not connected via USB (found BUS: \`$deviceType') and operation was therefore discarded."
    echowarn "Use \`--no-usb-check' option to bypass this policy at your own risks."
    echoerr "Exiting..."
    exit 1
  fi
  echogood "The selected device \`$selectedDevice' is connected through USB."
}

shouldWipeUSBKey() {
  typeset answer='y'
  echowarn "About to wipe out the content of device \`$selectedDevice'."
  if [ "$disableConfirmation" == 'false' ]; then
    read -r -p "         Are you sure you want to proceed? (y/n)>" answer
  else
    echowarn "Bypassing confirmation with \`-y, --assume-yes' option."
  fi
  if [ "$answer" == 'y' ]; then
    return 0
  else
    return 1
  fi
}

createMBRPartitionTable() {
  typeset -Ar mbrTypeCodes=([vfat]='c' [exfat]='7' [ntfs]='7' [ext2]='83' [ext3]='83' [ext4]='83' [f2fs]='83')
  typeset partitionOptions
  if [ "$notBootable" == true ]; then
    partitionOptions="$selectedPartition : start=2048, type=${mbrTypeCodes[$partitionType]}"
  else
    partitionOptions="$selectedPartition : start=2048, type=${mbrTypeCodes[$partitionType]}, bootable"
  fi
  echogood "Creating MBR partition table with \`sfdisk'..."
  # Create partition table
  echo "$partitionOptions" | sfdisk -W always "$selectedDevice" 2>&1 | indentAll || failAndExit "Failed to write USB device partition table."
  sync
}

# $1: not-bootable, default false. When true, the partition will not be bootable.
partitionUSB() {
  typeset notBootable=${false:-1}
  # These options always end up with the label flag setter
  typeset -Ar mkfsOpts=(
    [vfat]="-v -F 32 -n"
    [exfat]="-n"
    [ntfs]="-Q -L"
    [ext2]="-L"
    [ext3]="-L"
    [ext4]="-L"
    [f2fs]="-l"
  )
  unmountPartitions() {
    # unmount any partition on selected device
    mapfile -t devicePartitions < <(grep -oP "^\\K$selectedDevice\\S*" /proc/mounts)
    for partition in "${devicePartitions[@]}"; do
        if ! umount "$partition" > /dev/null; then
          failAndExit "Failed to unmount $partition. It's likely that partition is busy."
        fi
    done
  }
  eraseDevice() {
    echoinfo "Erasing contents of $selectedDevice..."
    # clean signature from selected device
    wipefs --all --force "$selectedDevice" &> /dev/null
    # erase drive
    dd if=/dev/zero of="$selectedDevice" bs=512 count=1 conv=notrunc status=none || failAndExit "Failed to erase USB device.\\nIt's likely that the device has been ejected and needs to be replugged manually.\\nYou can check the availability of USB drives with \`$scriptName -l' command."
    sync
  }
  formatPartition() {
    # format
    echogood "Creating $partitionType partition on \`$selectedPartition'..."
    # shellcheck disable=SC2086
    mkfs -V -t "$partitionType" ${mkfsOpts[$partitionType]} "$partitionLabel" "$selectedPartition" | indentAll || failAndExit "Failed to create $partitionType partition on USB device.\\nMake sure you have mkfs.$partitionType installed on your system."
  }
  if shouldWipeUSBKey; then
    unmountPartitions
    eraseDevice
    if [ "$shouldMakePartition" == 'true' ]; then
      createMBRPartitionTable
      formatPartition
    fi
  else
    failAndExit "Discarding operation."
  fi
}

mountUSB() {
  typeset type="$partitionType"
  usbMountPoint=$(createTempFolder usb) || exit 1
  echogood "Created USB device mount point at \`$usbMountPoint'"
  if ! mount -t "$type" "$selectedPartition" "$usbMountPoint" > /dev/null; then
    failAndExit "Could not mount USB device."
  fi
}

updateProgress() {
  typeset sp="/-\\|"
  # print when launched from terminal
  if tty -s; then
    printf "\\b%s" "${sp:i++%${#sp}:1}"
  fi
  sleep 1 #0.25
}

cleanProgress() {
  # print when launched from terminal
  if tty -s; then
    printf "\\b%s\\n" " "
  fi
}

syncWithProgress() {
  printProgress() {
    typeset -i isWriting=1
    typeset -i i=1
    echo -n "$scriptName: Synchronizing writes on device \`${selectedDevice}'    "
    while ((isWriting != 0)); do
      isWriting=$(awk '{ print $9 }' "/sys/block/${selectedDevice#/dev/}/stat")
      updateProgress
    done
    cleanProgress
  }
  sync & printProgress
}

copyWithRsync() {
  rsyncWithProgress() {
    typeset -i i=1
    typeset statusFile=$(mktemp)
    (rsync -r -q -I --no-links --no-perms --no-owner --no-group "$isoMountPoint"/. "$usbMountPoint"; echo "$?" > "$statusFile") &
    pid=$!
    echo -n "$scriptName: Copying files from ISO to USB device with \`rsync'    "
    while [ -e "/proc/$pid" ]; do
      updateProgress
    done
    cleanProgress
    typeset status=$(cat "$statusFile")
    rm "$statusFile"
    if [ ! "$status" -eq 0 ]; then
      failAndExit "Copy command with \`rsync' failed. It's likely that your device has not enough space to contain the ISO image."
    fi
  }
  checkpkg 'rsync'
  rsyncWithProgress
  syncWithProgress
}

copyWithDD() {
  ddWithProgress() {
    typeset -i i=1
    typeset statusFile=$(mktemp)
    (dd if="$selectedIsoFile" of="$selectedDevice" bs=4MB status=none ; echo "$?" > "$statusFile") &
    pid=$!
    echo -n "$scriptName: Copying files from ISO to USB device with \`dd'    "
    while [ -e "/proc/$pid" ]; do
      updateProgress
    done
    cleanProgress
    typeset status=$(cat "$statusFile")
    rm "$statusFile"
    if [ ! "$status" -eq 0 ]; then
      failAndExit "Copy command with \`dd' failed. It's likely that your device has not enough space to contain the ISO image."
    fi
  }
  ddWithProgress
  syncWithProgress
}

installSyslinux() {
  inferSyslinuxLocation() {
    typeset syslinuxFolder
    syslinuxFolder=$(find "$usbMountPoint" -type d -wholename '*/boot/syslinux')
    syslinuxFolder=${syslinuxFolder:-$(find "$usbMountPoint" -type d -wholename '*/syslinux')}
    if [ -z "$syslinuxFolder" ]; then
      syslinuxFolder="$usbMountPoint/syslinux"
      mkdir -p "$syslinuxFolder"
    fi
    echo "$syslinuxFolder"
  }
  echoinfo "Infering syslinux folder location..."
  typeset syslinuxFolder=$(inferSyslinuxLocation)
  echoinfo "Installing syslinux bootloader on \`$usbMountPoint'..."
  cp /usr/lib/syslinux/bios/*.c32 "$syslinuxFolder" | indentAll || failAndExit "Syslinux bootloader could not be installed."
  extlinux --install "$syslinuxFolder" | indentAll || failAndExit "Syslinux bootloader could not be installed."
  # Look for existing syslinux.cfg file
  # if [ -d "$usbMountPoint/isolinux" ]; then
  #   mv "$usbMountPoint/isolinux" "$usbMountPoint"/syslinux
  # fi
  # if [ -e "$usbMountPoint/syslinux/isolinux.cfg" ]; then
  #   mv "$usbMountPoint/syslinux/isolinux.cfg" "$usbMountPoint"/syslinux/syslinux.cfg
  # fi
}

checkAction() {
  typeset -ra actions=('help' 'version' 'format' 'install-dd' 'list-usb-drives')
  typeset -a enabledActions=()
  for act in "${actions[@]}"; do
    if [ "${userFlags[$act]}" == 'true' ]; then
      enabledActions+=("$act")
    fi
  done
  if ((${#enabledActions[@]} == 0)); then
    action='install-rsync'
  elif ((${#enabledActions[@]} == 1)); then
    action=${enabledActions[0]}
  else
    failAndExit "You cannot invoke multiple actions at once: $(joinBy '+' "${enabledActions[@]}")."
  fi
}

checkUserVars() {
  # check partition type
  if [ ! -z "${userVars[type]}" ]; then
    if [ "${userVars[type],,}" == fat32 ]; then
      userVars[type]=vfat
    fi
    if ! containsElement "${userVars[type]}" "${supportedFS[@]}"; then
      failAndExit "FS type \`${userVars[type]}' not supported.\\nSupported FS types: $(joinBy "," "${supportedFS[*]}")."
    fi
    if ! containsElement "$action" "install-rsync" "format"; then
      failAndExit "Cannot set partition type with action [$action].\\n\`-t, --type' option is compatible with [format] and [install-rsync] actions only."
    fi
  fi
  # check device
  if [ ! -z "${userVars[device]}" ]; then
    assertDeviceIsOK "${userVars[device]}"
  fi
  # Bootloader constrains
  if [ "${userFlags[bootloader]}" == true ]; then
    case $action in
      install-rsync);;
      install-dd) failAndExit "Cannot install a syslinux bootloader with \`dd' utility.\\nSyslinux bootloader targets FAT32 writable partitions only, which is not possible through \`dd' utility.";;
      *) failAndExit "Cannot install a syslinux bootloader with action [$action]." ;;
    esac
    checkpkg 'syslinux'
    if [ ! -z "${userVars[type]}" ] && [ "${userVars[type]}" != 'vfat' ]; then
      failAndExit "You cannot install syslinux bootloader on a \`${userVars[type]}' filesystem.\\nSyslinux targets FAT32 (vfat) filesystems only."
    fi
  fi

}

checkUserFlags() {
  # Autoselect security
  if [ "${userFlags[autoselect]}" == 'true' ] && [ "${userFlags[no-usb-check]}" == 'true' ]; then
    failAndExit "You cannot set \`-a, --autoselect' option while disabling USB check with \`--no-usb-check'."
  fi
  # warnings (only with sudo)
  if ((EUID == 0)); then
    # Eject format
    if [ "${userFlags[no-eject]}" == "true" ] && [ "$action" == "format" ]; then
      echowarn "You don't need to prevent device ejection through \`-J' flag with \`format' action."
    fi
    # Warn autoselecting while assume yes is false
    if [ "${userFlags[autoselect]}" == 'true' ] && [ "${userFlags[assume-yes]}" == 'false' ]; then
      echowarn "\`-a, --autoselect' option is enabled by default when \`-y, --asume-yes' option is not set."
    fi
  fi
}

checkFlagMatrix() {
    for key in "${!userVarsCompatibilityMatrix[@]}"; do
      if [ ! -z "${userVars[$key]}" ]; then
        #shellcheck disable=SC2086
        if ! containsElement "$action" ${userVarsCompatibilityMatrix[$key]}; then
          if [ "$key" == "iso-file" ]; then
            failAndExit "[$action] action doesn't require any arguments."
          else
            failAndExit "[$action] action doesn't support option \`--$key'."
          fi
        fi
      fi
    done
    for key in "${!userFlagsCompatibilityMatrix[@]}"; do
      if [ ! -z "${userFlags[$key]}" ]; then
        #shellcheck disable=SC2086
        if ! containsElement "$action" ${userFlagsCompatibilityMatrix[$key]}; then
          failAndExit "\`$action' action doesn't support option \`--$key'"
        fi
      fi
    done
}


cleanup() {
  if ((EUID == 0)); then
    if [ -d "$isoMountPoint" ]; then
      if umount "$isoMountPoint"; then
        rmdir "$isoMountPoint"
        echogood "ISO succesfully unmounted."
      else
        echowarn "Could not unmount ISO mount point."
      fi
    fi
    if [ -d "$usbMountPoint" ]; then
      if umount "$usbMountPoint"; then
        rmdir "$usbMountPoint"
        echogood "USB device partition succesfully unmounted."
      else
        echowarn "Could not unmount USB mount point."
      fi
    fi
    if [[ "$operationSuccess" =~ 'install' ]]; then
      if [ "$noDeviceEjection" == 'false' ]; then
        if eject "$selectedDevice" &> /dev/null; then
          echogood "USB device succesfully ejected.\\nYou can safely remove it!"
        else
          echowarn "Failed to eject device \`$selectedDevice'."
        fi
      else
        echoinfo "USB device ejection skipped with \`-J, --no-eject' option."
      fi
    fi
  fi
}

assignArguments() {
  # Command argument
  selectedIsoFile=${userVars[iso-file]:-''}
  # Option flags
  addSyslinuxBootloader=${userFlags[bootloader]:-'false'}
  disableConfirmation=${userFlags[assume-yes]:-'false'}
  autoselect=${userFlags[autoselect]:-'false'}
  disableMimeCheck=${userFlags[no-mime-check]:-'false'}
  strictMimeCheck=${userFlags[strict-mime-check]:-'false'}
  disableUSBCheck=${userFlags[no-usb-check]:-'false'}
  # Vars flags
  partitionType=${userVars[type]:-'vfat'}
  selectedDevice=${userVars[device]:-''}
  partitionLabel=${userVars[label]:-''}
  # Action-dependent flags
  case $action in
    install-rsync)
      shouldMakePartition='true'
      hasActionDuration='true'
      expectingISOFile='true'
      requiresRoot='true'
      noDeviceEjection=${userFlags[no-eject]:-'false'};;
    install-dd)
      shouldMakePartition='false'
      hasActionDuration='true'
      expectingISOFile='true'
      requiresRoot='true'
      noDeviceEjection=${userFlags[no-eject]:-'false'};;
    format)
      shouldMakePartition='true'
      hasActionDuration='true'
      expectingISOFile='false'
      requiresRoot='true'
      noDeviceEjection=${userFlags[no-eject]:-'true'};;
    version)
      shouldMakePartition='false'
      hasActionDuration='false'
      expectingISOFile='false'
      requiresRoot='false'
      noDeviceEjection=${userFlags[no-eject]:-'true'};;
    help)
      shouldMakePartition='false'
      hasActionDuration='false'
      expectingISOFile='false'
      requiresRoot='false'
      noDeviceEjection=${userFlags[no-eject]:-'true'};;
    list-usb-drives)
      shouldMakePartition='false'
      hasActionDuration='false'
      expectingISOFile='false'
      requiresRoot='false'
      noDeviceEjection=${userFlags[no-eject]:-'true'};;
  esac
}

startTimer() {
  startTime=$(date +%s)
}

stopTimerAndPrintLapsed() {
  endTime=$(date +%s)
  echogood "Took $((endTime - startTime)) seconds to perform \`$action' action."
  operationSuccess=$action
}

runSecurityAssessments() {
  configureLabel
  selectDevice
  startTimer
  assertDeviceIsOK "$selectedDevice"
  assertDeviceIsUSB
}

execWithRsync() {
  runSecurityAssessments
  mountIsoFile
  partitionUSB false
  mountUSB
  copyWithRsync
  if [ "$addSyslinuxBootloader" == 'true' ]; then
    installSyslinux
  fi
}

execWithDD() {
  runSecurityAssessments
  partitionUSB false
  copyWithDD
}

execFormat() {
  selectDevice
  startTimer
  configureLabel
  assertDeviceIsOK "$selectedDevice"
  assertDeviceIsUSB
  partitionUSB true
}

checkArguments() {
  checkAction
  checkUserVars
  checkUserFlags
}

main() {
  trap cleanup EXIT INT TERM
  initPckgManager "$@"
  parseArguments "$@"
  checkArguments
  assignArguments
  checkFlagMatrix
  checkPackages
  if [ "$expectingISOFile" == 'true' ]; then
    assertISOIsOK
  fi
  if [ "$requiresRoot" == 'true' ]; then
    checkSudo "$@"
  fi
  case "$action" in
    'install-dd') execWithDD "$@" ;;
    'install-rsync') execWithRsync "$@" ;;
    'format') execFormat "$@" ;;
    'list-usb-drives') listDevicesTable ;;
    'version') echo "$version";;
    'help') display_help;;
  esac
  if [ "$hasActionDuration" == 'true' ]; then
    stopTimerAndPrintLapsed
  fi
}

main "$@"
